Sensor_List <- Sensor_List[!names(Sensor_List) %in% quality_issues]
# Remove sensors with insufficient data to run imputation(12):
# at least two non-NA data points required per target day
# none of the following sensors have data for pre-covid periods
insufficient_data_issues <- c("BordduLacversest",
"BordduLacversouest",
"Maisonneuve_Berri",
"Maisonneuve_Papineau",
"Maisonneuve_Plessis",
"McGill_William",
"Querbes_StRoch",
"REV_4Peel_NotreDame",
"Villeray",
"Wellington_Charlevoix")
Sensor_List <- Sensor_List[!names(Sensor_List) %in% insufficient_data_issues]
# Remove data preceding 2016 for PontJacquesCartier
Sensor_List[["PontJacquesCartier"]] <- Sensor_List[["PontJacquesCartier"]][Sensor_List[["PontJacquesCartier"]]$Date >= as.Date("2016-01-01"), ]
# Define time periods with abnormal data
abnormal_data <- list(
CoteSainteCatherine_Stuart = c("2016-08-29", "2016-10-06"),
ChristopheColomb_Louvain   = c("2023-06-22", "2023-12-31"),
Maisonneuve_Peel           = c("2015-08-25", "2015-11-09"),
NotreDame                  = c("2020-11-20", "2021-04-19"),
ReneLevesque_Wolfe    = list(c("2018-06-09", "2019-07-23"),
c("2022-05-04", "2022-06-14")),
Valois_laFontaine          = c("2022-01-01", "2023-01-01"),
Viger_SaintUrbain          = c("2022-07-05", "2023-10-16")
)
# Function to set all data within abnormal ranges to NA
set_abnormal_to_na <- function(sensor_name, abnormal_ranges) {
sensor_data <- Sensor_List[[sensor_name]]
for (range in abnormal_ranges) {
sensor_data$Pass[sensor_data$Date >= as.Date(range[1]) & sensor_data$Date <= as.Date(range[2])] <- NA
}
Sensor_List[[sensor_name]] <<- sensor_data
}
# Apply abnormal to NA function
lapply(names(abnormal_data), function(name) {
ranges <- if (is.list(abnormal_data[[name]])) abnormal_data[[name]] else list(abnormal_data[[name]])
set_abnormal_to_na(name, ranges)
})
# Set thresholds for outliers
thresholds <- list(
ChristopheColomb_Louvain = 2500,
CamillienHoude1 = 3000,
Estacade = 500,
SaintUrbain = 4000,
SaintLaurent_Bellechasse = 13000,
REV_Bellechasse_13eme = 4000,
ReneLevesque_Wolfe = 6000,
Rachel3_Angus = 5500,
Rachel_Papineau = 9000,
Rachel_HoteldeVille = 6000,
PontLeGardeur = 1500,
PontJacquesCartier = 6000,
Parc_Duluth = 6000
)
# Set all data points above outlier thresholds to NA
for (sensor in names(thresholds)) {
Sensor_List[[sensor]]$Pass[Sensor_List[[sensor]]$Pass >= thresholds[[sensor]]] <- NA
}
# Define range of data to switch Na to 0
date_ranges <- list(
A25_Gouin = list(c("2021-10-01", "2023-12-31")),
Estacade = list(c("2019-08-01", "2023-06-16")),
MauriceDuplessis = list(c("2020-10-01", "2021-04-01"),c("2021-10-01", "2022-04-01")),
PisteDesCarrieres = list(c("2019-10-01", "2020-04-01"),c("2020-10-01", "2021-04-01"),c("2021-10-01", "2022-04-01")),
ParcStanley = list(c("2018-10-01", "2019-04-01"),c("2019-10-01", "2020-04-01"))
)
# Function to switch Na to 0
update_na_pass <- function(sensor_data, date_ranges) {
for (date_range in date_ranges) {
start_date <- as.Date(date_range[1])
end_date <- as.Date(date_range[2])
sensor_data$Pass[
sensor_data$Date >= start_date &
sensor_data$Date <= end_date &
is.na(sensor_data$Pass)
] <- 0
}
return(sensor_data)
}
# Apply Na to 0 function
for (sensor_name in names(date_ranges)) {
Sensor_List[[sensor_name]] <- update_na_pass(Sensor_List[[sensor_name]], date_ranges[[sensor_name]])
}
# If start day of the series is not the first of the month:
# add all dates till the first of the month as NA values
for (df_name in names(Sensor_List)) {
df <- Sensor_List[[df_name]]
if (day(df$Date[1]) != 1) {
start_date <- as.Date(format(df$Date[1], "%Y-%m-01"))# Uses first entry as a reference for month and year
end_date <- df$Date[1] - 1 # Day before the first entry
missing_dates <- seq.Date(start_date, end_date, by = "day")
missing_df <- data.frame(Date = missing_dates, Pass = NA)
Sensor_List[[df_name]] <- rbind(missing_df, df) %>%
arrange(Date)
}
}
# If start month of the series is not january:
# cut out any start year that is incomplete
adjust_start_to_january <- function(df) {
start_year <- year(df$Date[1])
start_month <- month(df$Date[1])
if (start_month != 1) {
df <- df %>% filter(year(Date) > start_year)
}
return(df)
}
# Apply the start year cutoff function to each sensor in the list
Sensor_List <- map(Sensor_List, adjust_start_to_january)
# If start month of the series is not january:
# cut out any start year that is incomplete
adjust_start_to_january <- function(df) {
start_year <- year(df$Date[1])
start_month <- month(df$Date[1])
if (start_month != 1) {
df <- df %>% filter(year(Date) > start_year)
}
return(df)
}
# Apply the start year cutoff function to each sensor in the list
Sensor_List <- map(Sensor_List, adjust_start_to_january)
# Extract test dataframe, and create a test version with 2016 data cut out
reference <- Sensor_List[["Berri1"]]
test <- reference %>%
mutate(Pass = if_else(year(Date) == 2016, NA_real_, Pass))
start_year <- year(test$Date[1])
start_day_of_year <- yday(test$Date[1])
# Convert to Multiple Time Series object
test_msts <- msts(test$Pass,
start = c(start_year, start_day_of_year),
seasonal.periods =c(7,365.25))
reference_msts <- msts(reference$Pass,
start = c(start_year, start_day_of_year),
seasonal.periods =c(7,365.25))
# Apply interpolation
test_interpolation <- na_seasplit(test_msts)
reference_msts <- na_seasplit(reference_msts)
# Calculate RMSE
differences <- test_interpolation - reference_msts
sqrt(mean(differences^2))
# Convert to Multiple Time Series objects and impute missing values
create_msts_and_impute <- function(df, df_name) {
start_year <- year(df$Date[1])
start_day_of_year <- yday(df$Date[1])
# create time series object
df_msts <- msts(df$Pass, start = c(start_year, start_day_of_year), seasonal.periods =c(7,365.25))
# imputation
if (any(is.na(df_msts))) {
df_msts_imp <- na_seasplit(df_msts)
plot_title <- df_name
plot <- ggplot_na_imputations(df_msts, df_msts_imp, title = plot_title)
ggsave(paste0("Outputs/Graphs/Imputed/Imp_", df_name, ".jpg"), plot, device = "jpg", width = 17, height = 9)
assign(paste0("msts_", df_name), df_msts_imp, envir = .GlobalEnv)# Save imputed time series object in global environment
} else {
assign(paste0("msts_", df_name), df_msts, envir = .GlobalEnv) # Save original time series object in global environment if no imputation needed
}
}
# Apply Imputation and plotting function
names_list <- names(Sensor_List)
for (i in seq_along(Sensor_List)) {
create_msts_and_impute(Sensor_List[[i]], names_list[i])
}
# Manual adjustments for Brebeuf_Rachel (no data for 2019, means imputation is underestimating this year)
Brebeuf_Rachel_df <- Sensor_List[["Brebeuf_Rachel"]]
Brebeuf_Rachel_before <- Brebeuf_Rachel_df %>% filter(Date < "2020-04-01")
Brebeuf_Rachel_after <- Brebeuf_Rachel_df  %>% filter(Date >= "2020-04-01")
start_year_a <- year(Brebeuf_Rachel_before$Date[1])
start_day_of_year_a <- yday(Brebeuf_Rachel_before$Date[1])
msts <- msts(Brebeuf_Rachel_before$Pass, start = c(start_year_a, start_day_of_year_a), seasonal.periods =c(7,365.25))
msts_before <- na_seasplit(msts)
ggplot_na_imputations(msts, msts_before, title = "Brebeuf_Rachel_before")
ggsave(filename = "Outputs/Graphs/Imputed/Imp_Brebeuf_Rachel_before.jpg", width = 17, height = 9, device = "jpeg")
start_year <- year(Brebeuf_Rachel_after$Date[1])
start_day_of_year <- yday(Brebeuf_Rachel_after$Date[1])
msts_after <- msts(Brebeuf_Rachel_after$Pass, start = c(start_year, start_day_of_year), seasonal.periods =c(7,365.25))
msts_join <- msts(c(msts_before, msts_after), start = c(start_year_a, start_day_of_year_a), seasonal.periods =c(7,365.25))
msts_Brebeuf_Rachel <- na_seasplit(msts_join)
ggplot_na_imputations(msts_join, msts_Brebeuf_Rachel, title = "Brebeuf_Rachel_after")
ggsave(filename = "Outputs/Graphs/Imputed/Imp_Brebeuf_Rachel_after.jpg", width = 17, height = 9, device = "jpeg")
# Manual adjustments for University_Milton (partial data for 2019, means imputation is underestimating this year)
University_Milton_df <- Sensor_List[["University_Milton"]]
University_Milton_before <- University_Milton_df %>% filter(Date < "2020-01-01")
University_Milton_after <- University_Milton_df  %>% filter(Date >= "2020-01-01")
start_year_a <- year(University_Milton_before$Date[1])
start_day_of_year_a <- yday(University_Milton_before$Date[1])
msts <- msts(University_Milton_before$Pass, start = c(start_year_a, start_day_of_year_a), seasonal.periods =c(7,365.25))
msts_before <- na_seasplit(msts)
ggplot_na_imputations(msts, msts_before, title = "University_Milton_before")
ggsave(filename = "Outputs/Graphs/Imputed/Imp_University_Milton_before.jpg", width = 17, height = 9, device = "jpeg")
start_year <- year(University_Milton_after$Date[1])
start_day_of_year <- yday(University_Milton_after$Date[1])
msts_after <- msts(University_Milton_after$Pass, start = c(start_year, start_day_of_year), seasonal.periods =c(7,365.25))
msts_University_Milton <- msts(c(msts_before, msts_after), start = c(start_year_a, start_day_of_year_a), seasonal.periods =c(7,365.25))
jpeg(filename = "Outputs/Graphs/Imputed/Imp_University_Milton.jpg",
width = 17, height = 9, units = "in", res = 300)
plot <- plot(msts_University_Milton)
print(plot)
dev.off()
# Manual adjustments for ReneLevesque_Wolfe (partial data for 2019, means imputation is underestimating this year)
ReneLevesque_Wolfe_df <- Sensor_List[["ReneLevesque_Wolfe"]]
# Manual adjustments for ReneLevesque_Wolfe (partial data for 2019, means imputation is underestimating this year)
ReneLevesque_Wolfe_df <- Sensor_List[["ReneLevesque_Wolfe"]]
ReneLevesque_Wolfe_before <- ReneLevesque_Wolfe_df %>% filter(Date < "2020-04-01")
ReneLevesque_Wolfe_after <- ReneLevesque_Wolfe_df  %>% filter(Date >= "2020-04-01")
start_year_a <- year(ReneLevesque_Wolfe_before$Date[1])
start_day_of_year_a <- yday(ReneLevesque_Wolfe_before$Date[1])
msts <- msts(ReneLevesque_Wolfe_before$Pass, start = c(start_year_a, start_day_of_year_a), seasonal.periods =c(7,365.25))
msts_before <- na_seasplit(msts)
ggplot_na_imputations(msts, msts_before, title = "ReneLevesque_Wolfe_before")
ggsave(filename = "Outputs/Graphs/Imputed/Imp_ReneLevesque_Wolfe_before.jpg", width = 17, height = 9, device = "jpeg")
start_year <- year(ReneLevesque_Wolfe_after$Date[1])
start_day_of_year <- yday(ReneLevesque_Wolfe_after$Date[1])
msts_after <- msts(ReneLevesque_Wolfe_after$Pass, start = c(start_year, start_day_of_year), seasonal.periods =c(7,365.25))
msts_join <- msts(c(msts_before, msts_after), start = c(start_year_a, start_day_of_year_a), seasonal.periods =c(7,365.25))
msts_ReneLevesque_Wolfe <- na_seasplit(msts_join)
ggplot_na_imputations(msts_join, msts_ReneLevesque_Wolfe, title = "ReneLevesque_Wolfe_after")
ggsave(filename = "Outputs/Graphs/Imputed/Imp_ReneLevesque_Wolfe_after.jpg", width = 17, height = 9, device = "jpeg")
convert_msts_to_vector <- function(msts_object) {
pass <- round(as.vector(msts_object))
data_frame <- data.frame(Pass = pass)
return(data_frame)
}
# Gather all elements of the environment into a list
msts_objects <- sapply(ls(), function(x) if (inherits(get(x), "msts")) x else NULL)
# Filter to keep only msts objects
msts_objects <- msts_objects[!sapply(msts_objects, is.null) &
names(msts_objects) != "ts" &
names(msts_objects) != "no_outlier" &
names(msts_objects) != "msts" &
names(msts_objects) != "msts_before" &
names(msts_objects) != "msts_after" &
names(msts_objects) != "msts_after" &
names(msts_objects) != "msts_join"]
# Change names in the list back into actual objects
Msts_List <- lapply(msts_objects, function(x) get(x))
# Convert msts objects to vector
Sensor_List_vector <- lapply(Msts_List, convert_msts_to_vector)
names(Sensor_List_vector) <- gsub("msts_", "", names(Sensor_List_vector))
# Paste Pass column from new vectors to old dataframes
Sensor_List_Final <- list()
for (name in names(Sensor_List)) {
if (name %in% names(Sensor_List_vector)) {
if (nrow(Sensor_List[[name]]) == nrow(Sensor_List_vector[[name]])) {
Sensor_List[[name]]$Pass <- Sensor_List_vector[[name]]$Pass
} else {
cat(sprintf("The number of rows does not match for '%s'. Replacement was not performed.\n", name))
}
}
Sensor_List_Final[[name]] <- Sensor_List[[name]]
}
# Bind the geodata to each dataframe
geodata <- SENSORS %>%distinct(ID, .keep_all = TRUE)
for(i in 1:nrow(geodata)) {
current_name <- geodata$Name[i]
current_longitude <- geodata$Longitude[i]
current_latitude <- geodata$Latitude[i]
target_df_index <- which(names(Sensor_List_Final) == current_name)
if(length(target_df_index) == 1) {
Sensor_List_Final[[target_df_index]]$Longitude <- current_longitude
Sensor_List_Final[[target_df_index]]$Latitude <- current_latitude
} else {
cat("No match:", current_name, "\n")
}
}
NAMES <- as.data.frame(names(Sensor_List_Final))
save(Msts_List, NAMES,
file = "SENSORS_imp_ts(day).Rda")
save(Sensor_List_Final, NAMES,
file = "SENSORS_imp_df(day).Rda")
required_packages <- c("tidyverse",
"openxlsx")
for(Package in required_packages){
if(!require(Package,character.only = TRUE)) {
install.packages(Package, dependencies=TRUE)
}
library(Package,character.only = TRUE)
}
load(file = "SENSORS_imp_df(day).rda")
load(file = "SENSORS.rda")
Sensor_Split <- split(SENSORS, SENSORS$Name)
summarize_day <- function(df) {
df %>%
group_by(Date) %>%
summarize(Pass = sum(Pass, na.rm = TRUE)) %>%
complete(Date = seq(min(Date), max(Date), by = "day")) %>%
arrange(Date) %>%
as.data.frame()
}
Sensor_List_Untreated <- map(Sensor_Split, summarize_day)
# Remove any sensors that do not have full data for 2018 and 2019
# This removes 28 sensors, so the count changes from N=48 to N=20
remove_list <- c(
"16eAvenue_Belanger",
"A25_Gouin",
"Bennett_Ontario",
"CamillienHoude1",
"Estacade",
"Maisonneuve_Greene",
"Maisonneuve_Vendome",
"MauriceDuplessis",
"NotreDameEst_Bellerive",
"ParcStanley",
"PisteDesCarrieres",
"PontIleBizard",
"PontLeGardeur",
"Rachel3_Angus",
"Rachel_PieIX",
"REV_Bellechasse_13eme",
"REV_Bellechasse_AvChristopheColomb",
"REV_Berri_SauveSB",
"REV_Lajeunesse_SauveNB",
"REV_StDenis_CarrieresNB",
"REV_StDenis_CarrieresSB",
"REV_StDenis_CastelnauNB",
"REV_StDenis_CastelnauSB",
"REV_StDenis_DuluthNB",
"REV_StDenis_RachelSB",
"SainteCroix_DuCollegeSainteCroix",
"Souligny_Saintemile",
"Valois_laFontaine"
)
Sensor_List_Reduced <- Sensor_List_Final[!(names(Sensor_List_Final) %in% remove_list)]
# Create Name column
create_name <- function(df_list) {
for (name in names(df_list)) {
df_list[[name]]$Name <- name
}
return(df_list)
}
Sensor_List_Reduced <- create_name(Sensor_List_Reduced)
Sensor_List_Untreated <- create_name(Sensor_List_Untreated)
# Convert to dataframe and calculate statistics
convert_and_calculate <- function(list) {
df <- bind_rows(list) %>%
as.data.frame() %>%
mutate(
Season = ifelse(
(month(Date) >= 3 & month(Date) <= 11) &
!(month(Date) == 3 & day(Date) < 13) &
!(month(Date) == 11 & day(Date) > 7), "High", "Low"),
Week = ifelse(wday(Date) %in% c(1, 7), "Wend", "Wday"),
Year = year(Date)
) %>%
filter(Year >= 2019) %>%
select(Date, Name, Pass, Year, Season, Week)
stats <- df %>%
group_by(Name, Year) %>%
summarise(
Wday = sum(Pass[Week == "Wday"]),
Wend = sum(Pass[Week == "Wend"]),
Low = sum(Pass[Season == "Low"]),
High = sum(Pass[Season == "High"]),
Pass = sum(Pass),
.groups = 'drop'
) %>%
mutate(
Wend_Pct = round((Wend / (Wday + Wend)) * 100, 2),
Low_Pct = round((Low / (Low + High)) * 100, 2),
Change = if_else(Year == min(Year), 0, round(((Pass - lag(Pass)) / lag(Pass)) * 100, 2))
) %>%
select(Year, Name, Wend_Pct, Low_Pct, Change, Pass, Wday, Wend, High, Low) %>%
arrange(Year, Name)
return(stats)
}
Sensor_Imputed <- convert_and_calculate(Sensor_List_Reduced)
Sensor_Untreated <- convert_and_calculate(Sensor_List_Untreated)
# Parallel to St-Denis REV (6)
ll <- c("ChristopheColomb_Louvain", "Boyer_Everett",
"Boyer_Rosemont", "SaintLaurent_Bellechasse",
"Brebeuf_Rachel", "SaintUrbain")
# Control sensors (11)
ctrl <- c("CoteSainteCatherine_Stuart",
"Maisonneuve_Marcil", "Maisonneuve_Peel",
"NotreDame", "University_Milton", "Berri1",
"Rachel_HoteldeVille", "Rachel_Papineau",
"ReneLevesque_Wolfe", "Viger_SaintUrbain",
"Parc_Duluth")
# Leisure sensors (3)
leisure <- c("PierreDupuy","PontJacquesCartier","EdmondValade")
# Apply group names
Sensor_Imputed <- Sensor_Imputed %>%
mutate(Group = case_when(
Name %in% ll ~ "ll",
Name %in% ctrl ~ "ctrl",
Name %in% leisure ~ "leisure"
))
Sensor_Untreated <- Sensor_Untreated %>%
mutate(Group = "Untreated")
# Summarize statistics for all sensors for each group
summarize_groups <- function(data, group_name, filter_condition) {
data %>%
filter(!!filter_condition) %>%
group_by(Year) %>%
summarize(
Name = NA,
Group = group_name,
Pass = sum(Pass, na.rm = TRUE),
Wday = sum(Wday, na.rm = TRUE),
Wend = sum(Wend, na.rm = TRUE),
High = sum(High, na.rm = TRUE),
Low = sum(Low, na.rm = TRUE)
) %>%
ungroup()
}
Total_all <- summarize_groups(Sensor_Imputed, "Control, leisure and parallel", expr(Group %in% c("ctrl", "leisure", "ll")))
Total_ctrl_leisure <- summarize_groups(Sensor_Imputed, "Control, leisure", expr(Group %in% c("ctrl", "leisure")))
Total_ctrl <- summarize_groups(Sensor_Imputed, "Control", expr(Group == "ctrl"))
Total_ll <- summarize_groups(Sensor_Imputed, "Parallel", expr(Group == "ll"))
Total_untreated <- summarize_groups(Sensor_Untreated, "Untreated", expr(Group == "untreated"))
# Remove these sensors for 2019 and 2023 periods
Sensor_Imputed_2023 <- Sensor_Imputed %>%
filter(Year %in% c(2019, 2023))%>%
filter(!(Name %in% c("Maisonneuve_Peel",
"PontJacquesCartier",
"EdmondValade")))
Total_all_2023 <- summarize_groups(Sensor_Imputed_2023, "Control, leisure and parallel", expr(Group %in% c("ctrl", "leisure", "ll")))
Total_ctrl_leisure_2023 <- summarize_groups(Sensor_Imputed_2023, "Control, leisure", expr(Group %in% c("ctrl", "leisure")))
Total_ctrl_2023 <- summarize_groups(Sensor_Imputed_2023, "Control", expr(Group == "ctrl"))
Total_ll_2023 <- summarize_groups(Sensor_Imputed_2023, "Parallel", expr(Group == "ll"))
# Calculate change of each year compared to 2019
covid_change <- function(x) {
df <- x %>%
reframe(
Year = Year,
Group = Group,
Pass = round(((Pass - Pass[Year == 2019]) / abs(Pass[Year == 2019])) * 100, 2),
Wday = round(((Wday - Wday[Year == 2019]) / abs(Wday[Year == 2019])) * 100, 2),
Wend = round(((Wend - Wend[Year == 2019]) / abs(Wend[Year == 2019])) * 100, 2),
High = round(((High - High[Year == 2019]) / abs(High[Year == 2019])) * 100, 2),
Low  = round(((Low - Low[Year == 2019]) / abs(Low[Year == 2019])) * 100, 2)
) %>%
filter(Year != "2019")%>%
select(Group, everything())
return(df)
}
# Apply the covid change calculations function to each group
Stats_Untreated <- covid_change(Total_untreated)
Stats_all <- covid_change(Total_all)
Stats_ctrl_leisure <- covid_change(Total_ctrl_leisure)
Stats_ctrl <- covid_change(Total_ctrl)
Stats_ll <- covid_change(Total_ll)
Stats_all_2023 <- covid_change(Total_all_2023)
Stats_ctrl_leisure_2023 <- covid_change(Total_ctrl_leisure_2023)
Stats_ctrl_2023 <- covid_change(Total_ctrl_2023)
Stats_ll_2023 <- covid_change(Total_ll_2023)
# Overwrite the 2023 data with the specific calculations for this year
overwrite_2023 <- function(data, overwrite) {
data <- data %>%
mutate(across(everything(), ~ ifelse(Year == 2023, overwrite[[cur_column()]], .)))
return(data)
}
Stats_all <- overwrite_2023(Stats_all,Stats_all_2023)
Stats_ctrl_leisure <- overwrite_2023(Stats_ctrl_leisure, Stats_ctrl_leisure_2023)
Stats_ctrl <- overwrite_2023(Stats_ctrl, Stats_ctrl_2023)
Stats_ll <- overwrite_2023(Stats_ll, Stats_ll_2023)
# Pivot tables and keep only covid drop statistics from total ridership
pivot <- function(x){
df  <- x  %>%
select(Year, Pass, Group) %>%
pivot_wider(names_from = Year, values_from = Pass)
return(df)
}
pivot_untreated <- pivot(Stats_Untreated)
pivot_all <- pivot(Stats_all)
pivot_ctrl_leisure <- pivot(Stats_ctrl_leisure)
pivot_ctrl <- pivot(Stats_ctrl)
pivot_ll <- pivot(Stats_ll)
# Combine tables
Stats_CompareGroups <- bind_rows(pivot_untreated,pivot_all,pivot_ctrl_leisure,pivot_ctrl,pivot_ll) %>%
select(-"2018")
# Combine tables
Stats_CompareGroups <- bind_rows(pivot_untreated,pivot_all,pivot_ctrl_leisure,pivot_ctrl,pivot_ll) %>%
select(-"2018")
# Combine tables
Stats_CompareGroups <- bind_rows(pivot_untreated,pivot_all,pivot_ctrl_leisure,pivot_ctrl,pivot_ll)
View(Stats_CompareGroups)
# Pivot table and calculate covid change stats
pivot_covid_change <- function(x){
df  <- x  %>%
select(Year, Name, Wday, Wend, High, Low, Pass, Group) %>%
pivot_wider(names_from = Year, values_from = c(Wday, Wend, High, Low, Pass))%>%
mutate(
Drop2020 = round(((Pass_2020-Pass_2019)/abs(Pass_2019))*100,2),
Drop2021 = round(((Pass_2021-Pass_2019)/abs(Pass_2019))*100,2),
Drop2022 = round(((Pass_2022-Pass_2019)/abs(Pass_2019))*100,2),
Drop2023 = round(((Pass_2023-Pass_2019)/abs(Pass_2019))*100,2),
Wday2020 = round(((Wday_2020-Wday_2019)/abs(Wday_2019))*100,2),
Wday2021 = round(((Wday_2021-Wday_2019)/abs(Wday_2019))*100,2),
Wday2022 = round(((Wday_2022-Wday_2019)/abs(Wday_2019))*100,2),
Wday2023 = round(((Wday_2023-Wday_2019)/abs(Wday_2019))*100,2),
Wend2020 = round(((Wend_2020-Wend_2019)/abs(Wend_2019))*100,2),
Wend2021 = round(((Wend_2021-Wend_2019)/abs(Wend_2019))*100,2),
Wend2022 = round(((Wend_2022-Wend_2019)/abs(Wend_2019))*100,2),
Wend2023 = round(((Wend_2023-Wend_2019)/abs(Wend_2019))*100,2),
High2020 = round(((High_2020-High_2019)/abs(High_2019))*100,2),
High2021 = round(((High_2021-High_2019)/abs(High_2019))*100,2),
High2022 = round(((High_2022-High_2019)/abs(High_2019))*100,2),
High2023 = round(((High_2023-High_2019)/abs(High_2019))*100,2),
Low2020  = round(((Low_2020-Low_2019)/abs(Low_2019))*100,2),
Low2021  = round(((Low_2021-Low_2019)/abs(Low_2019))*100,2),
Low2022  = round(((Low_2022-Low_2019)/abs(Low_2019))*100,2),
Low2023  = round(((Low_2023-Low_2019)/abs(Low_2019))*100,2))%>%
select(Group, Name, Drop2020, Drop2021, Drop2022, Drop2023, Wday2020, Wday2021, Wday2022, Wday2023,Wend2020, Wend2021, Wend2022, Wend2023, High2020, High2021, High2022, High2023, Low2020, Low2021, Low2022, Low2023) %>%
arrange(Group, Name)
return(df)
}
# apply function
Stats_Imputed <- pivot_covid_change(Sensor_Imputed)
write.xlsx(Stats_Imputed, file = "Outputs/Tables/Stats_Individual.xlsx")
write.xlsx(Stats_CompareGroups, file = "Outputs/Tables/Stats_Grouped.xlsx")
